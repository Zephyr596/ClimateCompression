experiment:
  # 留空则会自动根据算法、epsilon、tile 等信息组合名称
  name: null
  output_dir: results/

dataset:
  version: "500"
  dtype: "float32"

tiledb:
  codec: "zstd"
  level: 7
  tile: [32, 128, 128]
  overwrite: true

semantic_compression:
  algorithm: "tucker"
  epsilon: 1e-3
  algorithms:
    svd:
      rank: 20          # r值 for SVD
    rsvd:
      rank: 20
      oversampling: 10
      n_iter: 2
    tucker:
      ranks: [20, 40, 40]
    sz:
      mode: "abs"
      error_bound: 1e-3
    predictq:
      mode: "value_rel"
      error_bound: 5e-4
    zfp:
      block_size: 4
      error_bound: 1e-3
    wavelet3d:
      levels: 3
      error_bound: 1e-3
    neural:
      latent_dim: 64
      epochs: 200
      learning_rate: 1e-3
  # === E 的相关配置 ===
  error_correction:
    enable: true           # 是否启用E计算（关闭则只保留G）
    mode: "blockwise"      # 可选: "pointwise", "blockwise", "quantized"
    block_size: 8          # 仅在 blockwise 模式下有效
    dtype: "float32"       # 或 "int8" (用于 quantized)

evaluation:
  metrics: ["compression_ratio"]

sweep:
  # algorithms: ["svd", "rsvd", "tucker", "sz", "zfp", "wavelet3d", "neural"]
  algorithms: ["svd", "rsvd", "tucker", "sz", "zfp", "wavelet3d"]
  # algorithms: ["sz"]
  epsilons: [1e-4, 5e-4, 1e-3, 5e-3, 1e-2, 5e-2, 1e-1]
